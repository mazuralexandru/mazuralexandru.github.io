<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Explanation</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Mulish:ital,wght@0,200..1000;1,200..1000&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
    rel="stylesheet">
  <link rel="preload" href="./utils/fonts/pixelgrid-squarebolds.woff" as="font" type="font/woff" crossorigin="">
  <link rel="preload" href="./utils/fonts/pixelgrid-squareboldm.woff" as="font" type="font/woff" crossorigin="">
  <link rel="preload" href="./utils/fonts/pixelgrid-squareboldxl.woff" as="font" type="font/woff" crossorigin="">
  <link rel="stylesheet" href="./utils/styles/explanationStyle.css">
  <link href="./utils/styles/explanationPrismTheme.css" rel="stylesheet" />
</head>
<body>
  <h1>589. Graphics: Immediate vs. Retained Mode - Fundamental Distinction 2</h1>
<p>Another key difference between <code class="language-html">&lt;canvas&gt;</code> and <code class="language-html">&lt;svg&gt;</code> lies in their rendering approach: <strong>Immediate Mode</strong> vs. <strong>Retained Mode</strong>.</p>
<p><strong>1. Immediate Mode (<code class="language-html">&lt;canvas&gt;</code>)</strong></p>
<ul>
<li><strong>Concept:</strong> You issue drawing commands directly to the rendering context (e.g., <code class="language-js">ctx.fillRect(...)</code>, <code class="language-js">ctx.lineTo(...)</code>, <code class="language-js">ctx.stroke()</code>). The browser executes these commands immediately, drawing pixels directly onto the canvas bitmap surface.</li>
<li><strong>Memory:</strong> The browser <strong>does not remember</strong> the objects or shapes you drew, only the resulting grid of pixels. It doesn&#39;t maintain an internal model or &quot;scene graph&quot; of your drawing.</li>
<li><strong>Redrawing:</strong> If something needs to change (e.g., for animation, resizing, or reacting to user input), you typically need to <strong>clear</strong> the canvas (or parts of it) and <strong>re-execute all the necessary drawing commands</strong> in JavaScript to render the updated scene.</li>
<li><strong>API:</strong> Primarily driven by a <strong>JavaScript API</strong> (<code>CanvasRenderingContext2D</code> or <code>WebGLRenderingContext</code>).</li>
</ul>
<p><strong>2. Retained Mode (<code class="language-html">&lt;svg&gt;</code>)</strong></p>
<ul>
<li><strong>Concept:</strong> You define the graphic <strong>declaratively</strong> using XML-based markup (e.g., <code class="language-html">&lt;rect&gt;</code>, <code class="language-html">&lt;circle&gt;</code>, <code class="language-html">&lt;path&gt;</code>). The browser parses this markup and builds an <strong>internal object model</strong> (a DOM tree specific to the SVG) representing all the shapes and their properties.</li>
<li><strong>Memory:</strong> The browser <strong>retains</strong> this object model in memory. It &quot;knows&quot; there&#39;s a circle at position (x,y) with a specific radius and fill color.</li>
<li><strong>Redrawing:</strong> The browser handles redrawing automatically. If you change an attribute of an SVG element (e.g., change the <code>fill</code> color of a <code class="language-html">&lt;circle&gt;</code> using CSS or JavaScript DOM manipulation), the browser automatically updates the rendering based on the modified object model. You don&#39;t typically need to manually redraw the entire scene.</li>
<li><strong>API:</strong> Primarily defined by <strong>markup</strong>, but fully accessible and modifiable via standard <strong>DOM APIs</strong> (like <code>getElementById</code>, <code>setAttribute</code>, <code>classList</code>) using JavaScript, and styled using <strong>CSS</strong>.</li>
</ul>
<p><strong>Analogy:</strong></p>
<ul>
<li><strong>Canvas (Immediate):</strong> Painting on a physical canvas. You apply paint (pixels). To change something, you have to paint over it or repaint the whole section. The canvas only remembers the final paint, not the brushstrokes.</li>
<li><strong>SVG (Retained):</strong> Building with LEGO bricks. You define the structure (shapes). To change the color of a brick, you swap the brick (modify the DOM object). The structure itself remembers what bricks are where.</li>
</ul>
<p>✅ <strong>Observation:</strong> No code changes. Understand this difference in approach: <code class="language-html">&lt;canvas&gt;</code> involves immediate, pixel-level drawing commands via JS, forgotten after execution. <code class="language-html">&lt;svg&gt;</code> involves defining persistent shape objects via markup, which the browser retains and automatically redraws when modified.</p>
<p>✨ <strong>Key Takeaway:</strong> <code class="language-html">&lt;canvas&gt;</code> uses an immediate mode rendering model (JS draws pixels directly, no object memory). <code class="language-html">&lt;svg&gt;</code> uses a retained mode model (browser builds/retains a DOM of shapes from markup, redrawing automatically when the DOM changes).</p>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>